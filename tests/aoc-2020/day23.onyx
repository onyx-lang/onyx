#load "core/module"

use core {*}

cups : [..] i32

// Using this as a wrapping function, since the WASM modulus
// operator (%) doesn't appear to do the correct thing.
w :: (idx: $T, mod := cups.count) -> T {
    res := idx
    while res <  0     do res += ~~mod; 
    while res >= ~~mod do res -= ~~mod
    return res
}

get_idx :: (cups: [] i32, cup: i32) -> i32 {
    for i in 0 .. cups.count do if cups[i] == cup do return i
    return -1
}

simulate :: (cups: [] i32, moves := 100) {
    cw := memory.make_slice(i32, cups.count)
    defer cfree(cw.data)

    for i in 0 .. cups.count do cw[cups[i]] = cups[w(i + 1)]

    current_cup := cups[0]

    for move in 0 .. moves {
        next_1 := cw[current_cup]
        next_2 := cw[next_1]
        next_3 := cw[next_2]
        
        destination_cup := w(current_cup - 1)
        while  destination_cup == ~~next_1 ||
               destination_cup == ~~next_2 ||
               destination_cup == ~~next_3
        {
            destination_cup = w(destination_cup - 1)
        }

        cw[current_cup] = cw[next_3]
        cw[next_3] = cw[destination_cup]
        cw[destination_cup] = next_1

        current_cup = cw[current_cup]
    }

    cup := 0
    for i in 0 .. cups.count {
        cups[i] = cup
        cup = cw[cup]
    }
}

main :: (args: [] cstr) {
    cups_data := i32.[ 9, 6, 2, 7, 1, 3, 8, 5, 4 ]

    // Easier think about in zero-indexed
    for &cup in cups_data do *cup -= 1

    Array.init(&cups, 1000000)
    defer Array.free(&cups)

    for cup in cups_data do Array.push(&cups, cup)

    // Part 1
    // simulate(Array.to_slice(&cups))
    
    // Part 2
    for i in 9 .. 1000000 do Array.push(&cups, i)
    simulate(cups, 10000000)

    // Undo the zero-indexing
    for &cup in cups do *cup += 1

    // Part 1
    // one_idx := get_idx(Array.to_slice(&cups), 1)
    // for i in 1 .. 9 {
    //     printf("{}", cast(i32) cups[w(one_idx + i)])
    // }
    // printf("\n")

    // Part 2
    one_idx := get_idx(cups, 1)
    prod: i64 = cast(i64) (cups[w(one_idx + 1)]) * cast(i64) (cups[w(one_idx + 2)])
    printf("Cup product: {}\n", prod)
}
