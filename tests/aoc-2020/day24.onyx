#load "core/module"

use core {*}

Vec2 :: struct {
	x: i32 = 0
	y: i32 = 0
}

#overload
hash.hash :: (v: Vec2) -> u32 {
	return v.x * 11 + v.y * 17
}

#operator == (v1: Vec2, v2: Vec2) -> bool {
	return v1.x == v2.x && v1.y == v2.y
}

Hex_Directions := Vec2.[
	Vec2.{  1, 0 }, Vec2.{  1, -1 }, Vec2.{ 0, -1 }, 
    Vec2.{ -1, 0 }, Vec2.{ -1,  1 }, Vec2.{ 0,  1 }, 
]

Cell :: struct {
	alive : bool = false
	next  : bool = false;	
}

main :: (args: [] cstr) {
	contents := #file_contents "./input/day24.txt"

    file_stream := io.buffer_stream_make(contents)
	file := io.reader_make(&file_stream)

	grid := Map.make(Vec2, Cell); // `true` is black
	defer Map.free(&grid)

	while !io.reader_empty(&file) {
		line := io.read_line(&file)

		loc := Vec2.{ 0, 0 }
		s := 0
		for ch in line do switch s {
			case 0 do switch ch {
				case 'e' do loc.x += 1
				case 'w' do loc.x -= 1
				case 'n' do s = 1
				case 's' do s = 2
			}

			case 1 {
				switch ch {
					case 'e' { loc.x += 1; loc.y -= 1; }
					case 'w' { loc.y -= 1; }
				}
				s = 0
			}

			case 2 {
				switch ch {
					case 'e' { loc.y += 1; }
					case 'w' { loc.x -= 1; loc.y += 1; }
				}
				s = 0
			}
		}


		curr := Map.get(&grid, loc) ?? .{}
		Map.put(&grid, loc, .{ alive = !curr.alive })
	}

	// Part 1
	black_count := 0
	for &cell in grid.entries {
		if cell.value.alive do black_count += 1
	}	
	printf("Black count: {}\n", black_count)

	// Part 2
	cells_to_consider := Array.make(Vec2)
	defer Array.free(&cells_to_consider)

	for i in 0 .. 100 {
		for &cell in grid.entries {
			if cell.value.alive {
				Array.push(&cells_to_consider, cell.key)

				for &dir in Hex_Directions {
					Array.push(&cells_to_consider, .{
						x = cell.key.x + dir.x,
						y = cell.key.y + dir.y,
					})
				}
			}
		}

		for &cell in cells_to_consider {
			state  := Map.get(&grid, *cell) ?? .{}
			ncount := get_neighbor_count(&grid, *cell)

			if state.alive {
				state.next = ncount == 1 || ncount == 2
			} else {
				state.next = ncount == 2
			}

			Map.put(&grid, *cell, state)
		}

		for &cell in cells_to_consider {
			Map.update(&grid, *cell, [v]{ v.alive = v.next; })
		}

		Array.clear(&cells_to_consider)
	}

	black_count = 0
	for &cell in grid.entries {
		if cell.value.alive do black_count += 1
	}	
	printf("GOL black count: {}\n", black_count)
}

get_neighbor_count :: (grid: &Map(Vec2, Cell), pos: Vec2) -> u32 {
	count := 0

	for &dir in Hex_Directions {
		cell := Map.get(grid, Vec2.{ x = pos.x + dir.x, y = pos.y + dir.y }) ?? .{}
		if cell.alive do count += 1
	}

	return count
}
