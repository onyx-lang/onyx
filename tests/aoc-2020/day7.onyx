

use core {*}

BagGraph :: struct {
    nodes    : [..] &BagNode
    node_map : Map(str, &BagNode)
}

BagNode :: struct {
    color : str
    // Part 1
    // contained_in : [..] BagContainment

    // Part 2
    contain : [..] BagContainment
}

BagContainment :: struct {
    bag : &BagNode
    count : u32
}

bg_init :: (use graph: &BagGraph) {
    Array.init(&nodes, 16)
    Map.init(&node_map)
}

bg_free :: (use graph: &BagGraph) {
    Array.free(&nodes)
    Map.free(&node_map)
}

bg_get_node :: (use graph: &BagGraph, name: str) -> &BagNode {
    node := Map.get(&node_map, name) ?? null

    if node == null {
        node = calloc(sizeof BagNode)
        // Part 1
        // array.init(&node.contained_in, 2)
        // Part 2
        Array.init(&node.contain, 2)
        node.color = name

        Array.push(&nodes, node)
        Map.put(&node_map, node.color, node)
    }

    return node
}

main :: (args: [] cstr) {
    contents := #file_contents "./input/day7.txt"

    file := contents

    graph : BagGraph
    bg_init(&graph)
    defer bg_free(&graph)

    while true {
        name := str.read_until(&file, ' ', 1)
        if name.count == 0 do break

        container := bg_get_node(&graph, name)

        str.read_until(&file, ' ', 2)

        while true {
            if str.starts_with(file, " no") do break

            count := cast(u32, conv.parse_int(&file))
            str.advance(&file, 1)

            contained_name := str.read_until(&file, ' ', 1)
            contained := bg_get_node(&graph, contained_name)

            // Part 1
            // array.push(&contained.contained_in, BagContainment.{
            //     bag = container,
            //     count = count
            // })

            // Part 2
            Array.push(&container.contain, .{ bag = contained, count = count })

            bag_word := str.read_until_any(&file, 1, ' ', '\n')
            if bag_word[bag_word.count - 1] == '.' do break
        }

        str.advance_line(&file)
    }

    // Part 1
    // to_process_bags : [..] &BagNode
    // processed_bags: [..] &BagNode

    // array.init(&to_process_bags)
    // array.init(&processed_bags, 32)
    // array.push(&to_process_bags, bg_get_node(&graph, "shiny gold"))

    // while to_process_bags.count > 0 {
    //     bag := array.pop(&to_process_bags)
    //     array.push(&processed_bags, bag)
    //     
    //     for container in bag.contained_in {
    //         if !array.contains(&processed_bags, container.bag) && !array.contains(&to_process_bags, container.bag) {
    //             // printf("Adding {} to process.\n", container.bag.color)
    //             array.push(&to_process_bags, container.bag)
    //         }
    //     }
    // }

    // printf("Count: {}\n", processed_bags.count - 1)
    
    // Part 2
    to_process := Array.make(&BagNode)
    multiplier := Array.make(u32)
    Array.push(&to_process, bg_get_node(&graph, "shiny gold"))
    Array.push(&multiplier, 1)

    count := 0
    while to_process.count > 0 {
        bag := Array.pop(&to_process)
        mul := Array.pop(&multiplier)
        count += mul

        for bc in bag.contain {
            Array.push(&to_process, bc.bag)
            Array.push(&multiplier, bc.count * mul)
        }
    }

    printf("Count: {}\n", count - 1)
}
