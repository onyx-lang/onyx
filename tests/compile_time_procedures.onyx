

use core {*}

Test_VTable :: struct {
    first  : (i32) -> i32
    second : (i32) -> i32

    third  : (i32, i32) -> i32 = null_proc
}

test_vtable1 := Test_VTable.{
    first  = (a: i32) -> i32 { return a * 2; },
    second = (a: i32) -> i32 { return a + 2; },
}

test_vtable2 := Test_VTable.{
    first  = (a: i32) -> i32 { return a / 2; },
    second = (a: i32) -> i32 { return a - 2; },
}


Test_Thing :: struct {
    vt : &Test_VTable

    data : i32
}

// because of the work i did above, this also works now.
dummy := () { println("hello world!"); }


main :: (args: [] cstr) {
    dummy()

    t := Test_Thing.{ &test_vtable1, 10 }
    println(do_a_thing(&t))

    t.vt = &test_vtable2
    println(do_a_thing(&t))

    tmp_vt := Test_VTable.{ first = test_vtable1.second, second = test_vtable2.first, third = math.max }
    t.vt = &tmp_vt
    println(do_a_thing(&t))

    println(t.vt.first == test_vtable1.second)

    do_a_thing :: (use t: &Test_Thing) -> i32 {
        if vt.second == null_proc || vt.first == null_proc do return data

        res := data |> vt.second() |> vt.first()
        if vt.third != null_proc do res = vt.third(res, 20)

        return res
    }
}
