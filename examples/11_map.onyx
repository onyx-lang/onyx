#load "core/module"

use core {*}

main :: (args: [] cstr) {
    // Onyx does not have map type built into the language semantics,
    // but using polymorphic structs and overloaded procedures, it does
    // provide an 'any-to-any' hash map in it's core libraries.

    // To use it, simply create one like so:
    ages : Map(str, u32)
    Map.init(&ages)
    defer Map.free(&ages)

    // Alternatively you can use the Map.make function to achieve the
    // same thing:
    // ages := Map.make(str, u32, default = 0)

    // The defer statement ensures that the Map memory will be freed
    // when this procedure exits, no matter through which way. The
    // 'default' argument is used to specify what value should be
    // returned when the Map does not contain the requested key.

    // To put an entry into the Map, use the Map.put procedure.
    Map.put(&ages, "Dwight", 32)
    Map.put(&ages, "Jim", 25)
    Map.put(&ages, "Pam", 24)

    // To retrieve an entry's value, use the Map.get procedure.
    print_age :: (ages: &Map(str, u32), name: str) {
        age := Map.get(ages, name)
        printf("{}'s age is {}.\n", name, age)
    }

    print_age(&ages, "Dwight")
    print_age(&ages, "Jim")
    print_age(&ages, "Pam")
    print_age(&ages, "Michael")

    // You may noticed if you ran this program that it prints Michael's
    // age is 0. This is because there was entry for the key 'Michael',
    // and we provided the default of '0'. To ensure that a key is in the
    // Map, use the Map.has procedure

    println(Map.has(&ages, "Dwight"))
    println(Map.has(&ages, "Michael"))
}
