package core.conv

use core {map, string, array, math}

#package {
    custom_formatters: Map(type_expr, #type (^Format_Output, ^Format, rawptr) -> void);
    custom_parsers   : Map(type_expr, #type (rawptr, str, Allocator) -> bool);
}

//
// This procedure is run before main() as it is an #init procedure.
// It looks for all custom formatting and parsing definitions and
// registers them to be used in format_any and parse_any.
custom_formatters_initialized :: #init () {
    map.init(^custom_formatters, default=null_proc);
    map.init(^custom_parsers,    default=null_proc);

    #if Enable_Custom_Formatters {
        use package runtime.info;

        for type_idx: type_table.count {
            type := type_table[type_idx];
            if type.kind != .Struct do continue;

            s_info := cast(^Type_Info_Struct) type;
            for s_info.tags {
                if it.type == Custom_Format {
                    custom_format := cast(^Custom_Format) it.data;
                    custom_formatters[cast(type_expr) type_idx] = custom_format.format;
                }

                if it.type == Custom_Parse {
                    custom_parse := cast(^Custom_Parse) it.data;
                    custom_parsers[cast(type_expr) type_idx] = custom_parse.parse;
                }
            } 
        }

        format_procedures := get_procedures_with_tag(Custom_Format_Proc);
        defer delete(^format_procedures);

        for p: format_procedures {
            custom_format := p.tag;
            custom_formatters[custom_format.type] = *cast(^(^Format_Output, ^Format, rawptr) -> void, ^p.func);
        }


        parse_procedures := get_procedures_with_tag(Custom_Parse_Proc);
        defer delete(^parse_procedures);

        for p: parse_procedures {
            custom_parse := p.tag;
            custom_parsers[custom_parse.type] = *cast(^(rawptr, str, Allocator) -> bool, ^p.func);
        }
    }
}

//
// Registers a formatting function for a particular type. This type is
// inferred from the type of the third argument in the given function.
register_custom_formatter :: (formatter: (^Format_Output, ^Format, ^$T) -> void) {
    custom_formatters[T] = formatter;
}


//
// Registers a parsing function for a particular type. This type is
// inferred from the type of the first argument in the given function.
register_custom_parser :: (parser: (^$T, str, Allocator) -> bool) {
    custom_parsers[T] = parser;
}


//
// Tag-type used to specify how to format a structure.
//
//     @conv.Custom_Format.{ format_structure }
//     TheStructure :: struct { ... }
//
Custom_Format :: struct {
    format: (^Format_Output, ^Format, rawptr) -> void;
}


//
// Tag-type used to specify that a certain procedure should be used
// to format a type.
//
//     @conv.Custom_Format_Proc.{ TheStructure }
//     format_structure :: (output: ^conv.Format_Output, format: ^conv.Format, data: ^TheStructure) { ... }
//
Custom_Format_Proc :: struct {
    type: type_expr;
}


//
// Tag-type used to specify how to parse a structure.
//
//     @conv.Custom_Parse.{ parse_structure }
//     TheStructure :: struct { ... }
//
Custom_Parse :: struct {
    parse: (rawptr, str, Allocator) -> bool;
}


//
// Tag-type used to specify that a certain procedure should be used
// to parse a type.
//
//     @conv.Custom_Parse_Proc.{ TheStructure }
//     parse_structure :: (data: ^TheStructure, input: str, allocator: Allocator) -> bool { ... }
//
Custom_Parse_Proc :: struct {
    type: type_expr;
}

//
// Passed to any custom formatter. Wraps outputting data to any source,
// using a `flush` callback function. Use `write` to output a string.
// When the internal buffer is filled, `flush` is called to empty the
// buffer to the final destination.
Format_Output :: struct {
    data: ^u8;
    count: u32;
    capacity: u32;

    // When the data buffer fills, this procedure
    // is called with the data, allowing for the
    // buffer to be cleared and more to be written.
    flush: Format_Flush_Callback;

    write :: #match {
        (use output: ^Format_Output, c: u8) {
            if count >= capacity {
                if flush.func == null_proc                   do return;
                if !flush.func(flush.data, data[0 .. count]) do return;
                count = 0;
            }

            data[count] = c;
            count += 1;
        },

        (use output: ^Format_Output, s: str) {
            for c: s {
                if count >= capacity {
                    if flush.func == null_proc                   do return;
                    if !flush.func(flush.data, data[0 .. count]) do return;
                    count = 0;
                }

                data[count] = c;
                count += 1;
            }
        }
    }
}

Format_Flush_Callback :: struct {
    data: rawptr = null;
    func: (rawptr, str) -> bool = null_proc;
}


//
// Formatting options passed to a custom formatter.
Format :: struct {
    pretty_printing      := false;        // p
    quote_strings        := false;        // "
    single_quote_strings := false;        // '
    dereference          := false;        // *
    custom_format        := true;         // ! to disable
    interpret_numbers    := true;         // d to disable
    digits_after_decimal := cast(u32) 4;  // .2

    indentation   := cast(u32) 0;
    base          := cast(u64) 10;        // b16
    minimum_width := cast(u32) 0;         // w12
}

#local
flush_to_dynstr :: (dynstr: ^[..] u8, to_write: str) => {
    array.concat(dynstr, to_write);
    return true;
}



//
// Old aliases to not break old programs. Use format and format_va instead.
str_format :: format
str_format_va :: format_va


//
// Formats a string using the provided arguments and format specified string.
// This has many overloads to make it easy to work with.
format :: #match {}

#overload
format :: (buffer: [] u8, format: str, va: ..any) -> str {
    return format_va(buffer, format, ~~va); 
}

#overload
format :: (output: ^Format_Output, format: str, va: ..any) -> str {
    return format_va(output, format, ~~va); 
}

#overload
format :: (buffer: ^[..] u8, format: str, va: ..any) {
    buffer.count = buffer.capacity;
    out := format_va(*buffer, format, ~~va);
    buffer.count = out.count;
}

#overload
format :: (format: str, va: ..any) -> str {
    buffer : [256] u8;
    out    := make([..] u8);
    output := Format_Output.{
        ~~buffer, 0, buffer.count,
        flush=.{ ^out, flush_to_dynstr }
    };

    final := format_va(^output, format, ~~va);
    array.concat(^out, final);

    return out;
}

//
// Like format(), but takes the arguments as an array of `any`s, not a variadic argument array.
format_va :: #match {}

#overload
format_va :: (buffer: [] u8, format: str, va: [] any, flush := Format_Flush_Callback.{}) -> str {
    output := Format_Output.{ buffer.data, 0, buffer.count, flush };
    return format_va(^output, format, va);
}

#overload
format_va :: (buffer: ^[..] u8, format: str, va: [] any, flush := Format_Flush_Callback.{}) {
    buffer.count = buffer.capacity;
    out := format_va(*buffer, format, va, flush);
    buffer.count = out.count;
}

#overload
format_va :: (format: [] u8, va: [] any, allocator := context.allocator) -> str {
    buffer : [256] u8;
    out    := make([..] u8, allocator=allocator);
    output := Format_Output.{
        ~~buffer, 0, buffer.count,
        flush=.{ ^out, flush_to_dynstr }
    };

    final := format_va(^output, format, ~~va);
    array.concat(^out, final);

    return out;
}

#overload
format_va :: (output: ^Format_Output, format: str, va: [] any) -> str {
    vararg_index := 0;

    while i := 0; i < format.count {
        defer i += 1;

        ch := format[i];
        formatting := Format.{};

        if ch == #char "{" {
            if format[i + 1] == #char "{" {
                output->write(#char "{");
                i += 1;
                continue;
            }

            i += 1;
            while true {
                ch = format[i];

                switch ch {
                    case #char "*" {
                        i += 1;
                        formatting.dereference = true;
                    }

                    case #char "." {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        ch = format[i];
                        formatting.digits_after_decimal = digits;
                    }

                    case #char "p" {
                        i += 1;
                        formatting.pretty_printing = true;
                    }

                    case #char "x" {
                        i += 1;
                        formatting.base = 16;
                    }

                    case #char "b" {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        formatting.base = ~~digits;
                    }

                    case #char "w" {
                        i += 1;

                        digits := 0;
                        while format[i] >= #char "0" && format[i] <= #char "9" {
                            digits *= 10;
                            digits += ~~(format[i] - #char "0");
                            i += 1;
                        }

                        formatting.minimum_width = ~~digits;
                    }

                    case #char "!" {
                        i += 1;
                        formatting.custom_format = false;
                    }

                    case #char "\"" {
                        i += 1;
                        formatting.quote_strings = true;
                    }

                    case #char "'" {
                        i += 1;
                        formatting.single_quote_strings = true;
                    }

                    case #char "d" {
                        i += 1;
                        formatting.interpret_numbers = false;
                    }

                    case #char "}" {
                        arg := va[vararg_index];
                        vararg_index += 1;
                        format_any(output, ^formatting, arg);

                        break break;
                    }

                    case #default do break break;
                }
            }
        }

        if ch == #char "}" {
            if format[i + 1] == #char "}" {
                output->write(#char "}");
                i += 1;
                continue;
            }

            continue;
        }

        output->write(ch);
    }

    return .{ output.data, output.count };
}


//
// This procedure converts any value into a string, using the type information system.
// If a custom formatter is specified for the type, that is used instead.
// This procedure is generally not used directly; instead, through format or format_va.
format_any :: (output: ^Format_Output, formatting: ^Format, v: any) {
    use package runtime.info
    array :: package core.array;

    //
    // Dereference the any if the '*' format specifier was given.
    // Ignored if the value given is not a pointer.
    if formatting.dereference {
        ti := get_type_info(v.type);
        if ti.kind == .Pointer {
            formatting.dereference = false;

            new_any: any;
            new_any.type = (cast(^Type_Info_Pointer) ti).to;
            new_any.data = *(cast(^rawptr) v.data);
            format_any(output, formatting, new_any);
            return;
        }
    }

    //
    // Use a custom formatter, if one is registered for the type.
    if formatting.custom_format && custom_formatters->has(v.type) {
        custom_formatters[v.type](output, formatting, v.data);
        return;
    }

    switch v.type {
        case bool {
            value := *(cast(^bool) v.data);
            if value do output->write("true");
            else     do output->write("false");
        }

        case u8 {
            value := *(cast(^u8) v.data);

            if value > 31 {
                output->write(value);

            } else {
                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }
        }

        int_case :: macro (T: type_expr) {
            case T {
                value := *(cast(^T) v.data);

                ibuf : [128] u8;
                istr := i64_to_str(~~value, formatting.base, ~~ibuf, min_length=formatting.minimum_width);
                output->write(istr);
            }
        }

        uint_case :: macro (T: type_expr) {
            case T {
                value := *(cast(^T) v.data);

                ibuf : [128] u8;
                istr := u64_to_str(~~value, formatting.base, ~~ibuf, min_length=formatting.minimum_width);
                output->write(istr);
            }
        }

        int_case(i8);
        int_case(i16);
        int_case(i32);
        int_case(i64);
        uint_case(u16);
        uint_case(u32);
        uint_case(u64);

        case f32 {
            value := *(cast(^f32) v.data);

            fbuf : [128] u8;
            fstr := f64_to_str(~~value, ~~fbuf, formatting.digits_after_decimal);
            output->write(fstr);
        }

        case f64 {
            value := *(cast(^f64) v.data);

            fbuf : [128] u8;
            fstr := f64_to_str(~~value, ~~fbuf, formatting.digits_after_decimal);
            output->write(fstr);
        }

        case str {
            if formatting.quote_strings do output->write("\"");
            if formatting.single_quote_strings do output->write("'");
            width := formatting.minimum_width;
            to_output := *cast(^str) v.data;

            // @Todo // escape '"' when quote_strings is enabled.
            output->write(to_output);
            if to_output.count < width && !(formatting.quote_strings || formatting.single_quote_strings) {
                for width - to_output.count do output->write(#char " ");
            }

            if formatting.quote_strings do output->write("\"");
            if formatting.single_quote_strings do output->write("'");
        }

        case rawptr {
            value := *(cast(^rawptr) v.data);

            if value == null {
                output->write("(null)");
            } else {
                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }
        }

        case type_expr {
            value := *(cast(^type_expr) v.data);

            io :: package core.io

            buf : [256] u8;          

            // This is a little gross but the only way to output the type name for a type_expr
            // is through a io.Writer. That should maybe be changed in the future? Also, I think
            // 256 bytes is enough for the name of a type but I'm not entirely sure...
            stream := io.buffer_stream_make(~~buf, fixed=true);
            writer := io.writer_make(^stream, 0);
            write_type_name(^writer, value);
            io.writer_flush(^writer);

            output->write(io.buffer_stream_to_str(^stream));
        }

        case #default {
            info := get_type_info(v.type);

            if info.kind == .Struct {
                s := cast(^Type_Info_Struct) info;

                if s.constructed_from == Optional {
                    opt := cast(^?bool) v.data;

                    if opt.has_value {
                        format := *formatting;
                        format.quote_strings = true;

                        output->write("Some(");
                        format_any(output, ^format, .{ ~~(cast(^u8) v.data + s.members[1].offset), s.members[1].type });
                        output->write(")");

                    } else {
                        output->write("None");
                    }

                    return;
                }

                if s.name.count > 0 {
                    output->write(s.name);
                    output->write(" { ");
                } else {
                    output->write("{ ");
                }

                {
                    format := *formatting;
                    format.quote_strings = true;
                    if format.pretty_printing {
                        format.indentation += 4;
                    }
                    
                    for ^member: s.members {
                        if member != s.members.data do output->write(", ");

                        if formatting.pretty_printing {
                            output->write(#char "\n");
                            for i: format.indentation do output->write(#char " ");
                        }

                        output->write(member.name);
                        output->write(" = ");

                        format_any(output, ^format, .{ ~~(cast(^u8) v.data + member.offset), member.type });
                    }
                }
                
                if formatting.pretty_printing {
                    output->write(#char "\n");
                    for i: formatting.indentation do output->write(#char " ");
                    output->write("}");
                    
                } else {
                    output->write(" }");
                }
            }

            if info.kind == .Function {
                output->write("func[");

                value := *(cast(^i32) v.data);

                ibuf : [128] u8;
                istr := i64_to_str(~~value, 10, ~~ibuf);
                output->write(istr);

                output->write("]");
            }

            if info.kind == .Pointer {
                value := *(cast(^rawptr) v.data);

                ibuf : [128] u8;
                istr := i64_to_str(~~value, 16, ~~ibuf, prefix=true);
                output->write(istr);
            }

            // This assumes that the following type_info kinds are basically the same.
            if info.kind == .Dynamic_Array || info.kind == .Slice || info.kind == .Variadic_Argument {
                if formatting.pretty_printing {
                    output->write("[");
                } else {
                    output->write("[ ");
                }

                a := cast(^Type_Info_Dynamic_Array) info;
                arr := cast(^array.Untyped_Array) v.data;
                data  := arr.data;
                count := arr.count;

                format := *formatting;
                format.quote_strings = true;
                if format.pretty_printing do format.indentation += 4;

                for i: count {
                    if i != 0 do output->write(", ");

                    if formatting.pretty_printing {
                        output->write("\n");
                        for _: format.indentation do output->write(#char " ");
                    }

                    format_any(output, ^format, .{ ~~(cast(^u8) data + get_type_info(a.of).size * i), a.of });
                }


                if formatting.pretty_printing {
                    format.indentation -= 4;
                    output->write("\n");
                    for _: format.indentation do output->write(#char " ");
                    output->write(#char "]");

                } else {
                    output->write(" ]");
                }
            }

            if info.kind == .Array {
                output->write("[ ");

                a := cast(^Type_Info_Array) info;
                data := v.data;

                for i: a.count {
                    if i != 0 do output->write(", ");

                    format_any(output, formatting, .{ ~~(cast(^u8) data + get_type_info(a.of).size * i), a.of });
                }

                output->write(" ]");
            }

            if info.kind == .Enum {
                e := cast(^Type_Info_Enum) info;

                value: u64;
                switch e.backing_type {
                    case i8,  u8  do value = cast(u64) *(cast(^u8) v.data);
                    case i16, u16 do value = cast(u64) *(cast(^u16) v.data);
                    case i32, u32 do value = cast(u64) *(cast(^u32) v.data);
                    case i64, u64 do value = cast(u64) *(cast(^u64) v.data);
                    case #default do assert(false, "Bad enum backing type");
                }

                if !formatting.interpret_numbers {
                    format_any(output, formatting, .{^value, u64});
                    break;
                }

                if !e.is_flags {
                    for ^member: e.members {
                        if value == member.value {
                            output->write(member.name);
                            break break;
                        }
                    }

                    output->write("UNKNOWN");

                } else {
                    first := true;
                    for ^member: e.members {
                        if value & member.value != 0 {
                            if !first do output->write(" | ");
                            output->write(member.name);
                            first = false;
                        }
                    }

                    if first {
                        output->write("None");
                    }
                }
            }

            if info.kind == .Distinct {
                d := cast(^Type_Info_Distinct) info;

                if formatting.interpret_numbers {
                    output->write(d.name);
                    output->write("[");
                }

                format_any(output, formatting, any.{ v.data, d.base_type });

                if formatting.interpret_numbers {
                    output->write("]");
                }
            }
        }
    }
}
