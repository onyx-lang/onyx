package runtime.platform

use runtime
use core {package, *}
use wasi

#if runtime.runtime != .Wasi {
    #error "The file system library is currently only available on the WASI runtime, and should only be included if that is the chosen runtime."
}

use wasi {
    FileDescriptor,
    FDFlags, OFlags, Rights,
    LookupFlags, Errno,
    IOVec, Size,
    FileStat, Whence
}

FileData :: struct {
    fd     : FileDescriptor = -1

    mode   : os.OpenMode = .Invalid
    rights : Rights   = ~~ 0
    flags  : FDFlags  = ~~ 0
}

__file_open :: (path: str, mode := os.OpenMode.Read) -> (FileData, os.FileError) {
    // Requesting all of the rights because why not.
    rights :=
        Rights.DataSync |
        Rights.Read |
        Rights.Seek |
        Rights.FdStatSetFlags |
        Rights.Sync |
        Rights.Tell |
        Rights.Write |
        Rights.Advise |
        Rights.Allocate |
        Rights.PathCreateDirectory |
        Rights.PathCreateFile |
        Rights.PathLinkSource |
        Rights.PathLinkTarget |
        Rights.PathOpen |
        Rights.ReadDir |
        Rights.PathReadlink |
        Rights.PathRenameSource |
        Rights.PathRenameTarget |
        Rights.PathFilestatGet |
        Rights.PathFilestateSetSize |
        Rights.PathFilestateSetTimes |
        Rights.FilestatGet |
        Rights.FilestatSetSize |
        Rights.FilestatSetTimes |
        Rights.PathSymlink |
        Rights.PathRemoveDirectory |
        Rights.PathUnlinkFile |
        Rights.PollFDReadWrite

    open_flags := cast(OFlags) 0
    fd_flags := FDFlags.Sync

    switch mode {
        case .Write {
            open_flags |= OFlags.Creat | OFlags.Trunc
            rights     |= Rights.Write | Rights.Seek | Rights.Tell
        }

        case .Append {
            open_flags |= OFlags.Creat
            rights     |= Rights.Write | Rights.Seek | Rights.Tell
            fd_flags   |= FDFlags.Append
        }

        case .Read {
            rights |= Rights.Read | Rights.Seek | Rights.Tell
        }
    }

    file := FileData.{ fd = -1 }
    file.mode   = mode
    file.rights = rights
    file.flags  = fd_flags

    // Currently the directory's file descriptor appears to always be 3
    // However, this is not necessarily correct, so also try a preopened directory
    for DIR_FD in .[ 3, 4 ] {
        if err := wasi.path_open(
            DIR_FD,
            .SymLinkFollow,
            path,
            open_flags,
            rights,
            rights,
            fd_flags,
            &file.fd)
            err == .Success {
                return file, .None
        }
    }

    // @TODO // provide a better error code.
    return file, .NotFound
}

__file_close :: (file: FileData) -> os.FileError {
    if wasi.fd_close(file.fd) != .Success {
        return .BadFile
    }

    return .None
}

__file_stat :: (path: str, out: &os.FileStat) -> bool {
    fs: wasi.FileStat

    exists := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_filestat_get(it, .SymLinkFollow, path, &fs)
        if err == .Success {
            exists = true
            out.size = ~~ fs.size
            out.change_time = fs.ctim / 1000000
            out.accessed_time = fs.atim / 1000000
            out.modified_time = fs.mtim / 1000000

            switch fs.filetype {
                case .RegularFile do out.type = .RegularFile
                case .Directory do out.type = .Directory
                case .SymLink do out.type = .SymLink
                case _ do out.type = .Unknown
            }
        }
    }

    return exists
}

__file_exists :: (path: str) -> bool {
    fs: wasi.FileStat

    exists := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_filestat_get(it, .SymLinkFollow, path, &fs)
        if err == .Success do exists = true
    }

    return exists
}

__file_remove :: (path: str) -> bool {
    removed := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_unlink_file(it, path)
        if err == .Success do removed = true
    }

    return removed
}

__file_rename :: (old_path: str, new_path: str) -> bool {
    renamed := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_rename(it, old_path, it, new_path)
        if err == .Success do renamed = true
    }

    return renamed
}

__file_stream_vtable := io.Stream_Vtable.{
    seek = (use fs: &os.File, to: i32, whence: io.SeekFrom) -> io.Error {
        // Currently, the new offset is just ignored.
        newoffset : wasi.Filesize
        error := wasi.fd_seek(data.fd, ~~ to, ~~ whence, &newoffset)
        if error != .Success do return .BadFile

        return .None
    },

    tell = (use fs: &os.File) -> Result(u32, io.Error) {
        location : wasi.Filesize
        error := wasi.fd_tell(data.fd, &location)
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = ~~location }
    },

    read = (use fs: &os.File, buffer: [] u8) -> Result(u32, io.Error) {
        bytes_read : wasi.Size
        vec   := IOVec.{ buf = cast(u32) buffer.data, len = buffer.count }
        error := wasi.fd_read(data.fd, &vec, 1, &bytes_read)
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = bytes_read }
    },

    read_at = (use fs: &os.File, at: u32, buffer: [] u8) -> Result(u32, io.Error) {
        bytes_read : wasi.Size
        vec   := IOVec.{ buf = cast(u32) buffer.data, len = buffer.count }
        error := wasi.fd_pread(data.fd, &vec, 1, ~~at, &bytes_read)

        // FIX: Maybe report io.Error.OutOfBounds if the 'at' was out of bounds?
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = bytes_read }
    },

    read_byte = (use fs: &os.File) -> Result(u8, io.Error) {
        bytes_read : wasi.Size
        byte  : u8
        vec   := IOVec.{ buf = cast(u32) &byte, len = 1}
        error := wasi.fd_read(data.fd, &vec, 1, &bytes_read)
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = byte }
    },

    write = (use fs: &os.File, buffer: [] u8) -> Result(u32, io.Error) {
        bytes_written : wasi.Size
        vec   := IOVec.{ buf = cast(u32) buffer.data, len = buffer.count }
        error := wasi.fd_write(data.fd, &vec, 1, &bytes_written)
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = bytes_written }
    },

    write_at = (use fs: &os.File, at: u32, buffer: [] u8) -> Result(u32, io.Error) {
        bytes_written : wasi.Size
        vec   := IOVec.{ buf = cast(u32) buffer.data, len = buffer.count }
        error := wasi.fd_pwrite(data.fd, &vec, 1, ~~at, &bytes_written)

        // FIX: Maybe report io.Error.OutOfBounds if the 'at' was out of bounds?
        if error != .Success do return .{ Err = .BadFile }

        return .{ Ok = bytes_written }
    },

    write_byte = (use fs: &os.File, byte: u8) -> io.Error {
        bytes_written : wasi.Size
        byte_to_write := byte
        vec   := IOVec.{ buf = cast(u32) &byte_to_write, len = 1 }
        error := wasi.fd_write(data.fd, &vec, 1, &bytes_written)
        if error != .Success do return .BadFile

        return .None
    },

    close = (use fs: &os.File) -> io.Error {
        __file_close(data)
        return .None
    },

    flush = (use fs: &os.File) -> io.Error {
        wasi.fd_datasync(data.fd)
        return .None
    },

    size = (use fs: &os.File) -> i32 {
        file_stat: FileStat
        if wasi.fd_filestat_get(data.fd, &file_stat) != .Success do return 0

        return ~~ file_stat.size
    },

    poll = (use fs: &os.File, ev: io.PollEvent, timeout: i32) -> Result(bool, io.Error) {
        p: [1] PollDescription = .[.{
            fd = data.fd,
            in_events = ev,
        }]

        runtime.platform.__poll(p, timeout)

        return .{ Ok = p[0].out_events == ev }
    }
}


WasiDirectory :: struct {
    dir_fd: FileDescriptor
    last_cookie: wasi.DirCookie
}

DirectoryData :: &WasiDirectory

__dir_open :: (path: str, dir: &DirectoryData) -> bool {
    dir_fd: FileDescriptor

    DIR_PERMS  := Rights.PathOpen | .ReadDir | .PathReadlink | .FilestatGet | .PathFilestatGet
    FILE_PERMS := Rights.Read | .Seek | .Tell | .FilestatGet | .PollFDReadWrite

    for .[3, 4] {
        err := wasi.path_open(it, .SymLinkFollow, path, .Directory, DIR_PERMS, FILE_PERMS, .Sync, &dir_fd)
        if err != .Success do continue

        d := new(WasiDirectory)
        d.dir_fd = dir_fd
        d.last_cookie = 0

        *dir = d
        return true
    }

    return false
}

__dir_close :: (dir: DirectoryData) {
    wasi.fd_close(dir.dir_fd)
    if dir do cfree(dir)
}

__dir_read :: (dir: DirectoryData, out_entry: &os.DirectoryEntry) -> bool {
    buffer: [512] u8
    bufused: u32

    err := wasi.fd_readdir(dir.dir_fd, ~~buffer, 512, dir.last_cookie, &bufused)
    if err != .Success || bufused == 0 do return false

    dirent := cast(& wasi.DirEnt) buffer
    switch dirent.d_type {
        case .Unknown do out_entry.type = .Unknown
        case .BlockDevice do out_entry.type = .Block
        case .CharDevice do out_entry.type = .Char
        case .Directory do out_entry.type = .Directory
        case .RegularFile do out_entry.type = .RegularFile
        case .SymLink do out_entry.type = .SymLink
        case _ do out_entry.type = .Other
    }

    out_entry.identifier = ~~dirent.d_ino
    out_entry.name_length = dirent.d_namlen
    memory.set(~~&out_entry.name_data, 0, 256)
    memory.copy(~~&out_entry.name_data, ~~(cast([&] wasi.DirEnt) dirent + 1), math.min(dirent.d_namlen, sizeof typeof out_entry.name_data))

    dir.last_cookie = dirent.d_next
    return true
}

__dir_create :: (path: str) -> bool {
    created := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_create_directory(it, path)
        if err == .Success do created = true
    }

    return created
}

__dir_remove :: (path: str) -> bool {
    removed := false
    for .[3, 4] { // Trying both preopened directories
        err := wasi.path_remove_directory(it, path)
        if err == .Success do removed = true
    }

    return removed
}


#if !#defined(runtime.vars.WASIX) {
    __chdir  :: (path: str) => false
    __getcwd :: () => ""
}
