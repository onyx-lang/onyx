package wasi

#if !#defined(WASI_VERSION) {
    WASI_VERSION :: "wasi_snapshot_preview1"
}

Size      :: #type u32;
Filesize  :: #type u64;
Timestamp :: #type u64;

ClockID   :: enum (u32) {
    Realtime         :: 0x00;
    Monotonic        :: 0x01;
    ProcessCPUTimeID :: 0x02;
    ThreadCPUTimeID  :: 0x03;
}

Errno :: enum (u16) {
    Success      :: 0x00;
    TooBig       :: 0x01;
    Access       :: 0x02;
    AddrInUse    :: 0x03;
    AddrNotAvail :: 0x04;
    AFNoSupport  :: 0x05;
    Again        :: 0x06;
    Already      :: 0x07;
    BadFile      :: 0x08;
    BadMsg       :: 0x09;
    Busy         :: 0x0a;
    Canceled     :: 0x0b;
    Child        :: 0x0c;
    ConnAborted  :: 0x0d;
    ConnRefused  :: 0x0e;
    ConnReset    :: 0x0f;
    DeadLock     :: 0x10;
    DestAddrReq  :: 0x11;
    Domain       :: 0x12;
    DQUOT        :: 0x13;
    Exist        :: 0x14;
    Fault        :: 0x15;
    FileTooBig   :: 0x16;
    HostUnreach  :: 0x17;
    IdentRemoved :: 0x18;
    IllegalSeq   :: 0x19;
    InProgress   :: 0x1a;
    Interrupt    :: 0x1b;
    Invalid      :: 0x1c;
    IO           :: 0x1d;
    IsConnection :: 0x1e;
    IsDirectory  :: 0x1f;
    Loop         :: 0x20;
    MFile        :: 0x21;
    MLink        :: 0x22;
    MsgSize      :: 0x23;
    MultiHop     :: 0x24;
    NameTooLong  :: 0x25;
    NetDown      :: 0x26;
    NetReset     :: 0x27;
    NetUnreach   :: 0x28;
    NFile        :: 0x29;
    NoBufs       :: 0x2a;
    NoDev        :: 0x2b;
    NoEntry      :: 0x2c;
    NoExec       :: 0x2d;
    NoLock       :: 0x2e;
    NoLink       :: 0x2f;
    NoMemory     :: 0x30;
    NoMsg        :: 0x31;
    NoProtoOpt   :: 0x32;
    NoSpace      :: 0x33;
    NoSys        :: 0x34;
    NotConn      :: 0x35;
    NotDir       :: 0x36;
    NotEmpty     :: 0x37;
    NotRecover   :: 0x38;
    NotSock      :: 0x39;
    NotSupported :: 0x3a;
    NoTTY        :: 0x3b;
    NXIO         :: 0x3c;
    Overflow     :: 0x3d;
    OwnerDead    :: 0x3e;
    Permission   :: 0x3f;
    Pipe         :: 0x40;
    Protocol     :: 0x41;
    ProtoNoSup   :: 0x42;
    Prototype    :: 0x43;
    Range        :: 0x44;
    ReadonlyFS   :: 0x45;
    SeekPipe     :: 0x46;
    Search       :: 0x47;
    Stale        :: 0x48;
    Timedout     :: 0x49;
    TextBusy     :: 0x4a;
    XDev         :: 0x4b;

    NotCapable   :: 0x4c;
}

Rights :: enum #flags (u64) {
    DataSync;
    Read;
    Seek;
    FdStatSetFlags;
    Sync;
    Tell;
    Write;
    Advise;
    Allocate;
    PathCreateDirectory;
    PathCreateFile;
    PathLinkSource;
    PathLinkTarget;
    PathOpen;
    ReadDir;
    PathReadlink;
    PathRenameSource;
    PathRenameTarget;
    PathFilestatGet;
    PathFilestateSetSize;
    PathFilestateSetTimes;
    FilestatGet;
    FilestatSetSize;
    FilestatSetTimes;
    PathSymlink;
    PathRemoveDirectory;
    PathUnlinkFile;
    PollFDReadWrite;
    SockShutdown;
}

FileDescriptor :: #type i32;

IOVec :: struct {
    buf : u32; // actually a &u8, but WASM is 32-bit at the moment;
    len : u32;
}

CIOVec :: #type IOVec; // Constant IOVec

FileDelta :: #type i64;

Whence :: enum (u8) {
    Set :: 0x00;
    Cur :: 0x01;
    End :: 0x02;
}

DirCookie  :: #type u64;
DirNameLen :: #type u32;
INode      :: #type u64;

Filetype :: enum (u8) {
    Unknown      :: 0x00;
    BlockDevice  :: 0x01;
    CharDevice   :: 0x02;
    Directory    :: 0x03;
    RegularFile  :: 0x04;
    SocketDgram  :: 0x05;
    SocketStream :: 0x06;
    SymLink      :: 0x07;
}

DirEnt :: struct {
    d_next   : DirCookie;
    d_ino    : INode;
    d_namlen : DirNameLen;
    d_type   : Filetype;
}

Advice :: enum (u8) {
    Normal     :: 0x00;
    Sequential :: 0x01;
    Random     :: 0x02;
    WillNeed   :: 0x03;
    DontNeed   :: 0x04;
    NoReuse    :: 0x05;
}

FDFlags :: enum #flags (u16) {
    Append;
    DSync;
    NonBlock;
    RSync;
    Sync;
}

FDStat :: struct {
    fs_filetype          : Filetype;
    fs_flags             : FDFlags;
    fs_rights_base       : Rights;
    fs_rights_inheriting : Rights;
}

Device :: #type u64;

FSTFlags :: enum #flags (u16) {
    ATIM;
    ATIM_NOW;
    MTIM;
    MTIM_NOW;
}

LookupFlags :: enum #flags (u32) {
    SymLinkFollow;
}

OFlags :: enum #flags (u16) {
    Creat;
    Directory;
    FailIfExists;
    Trunc;
}

LinkCount :: #type u64;

FileStat :: struct {
    dev      : Device;
    ino      : INode;
    filetype : Filetype;

    // ANGER(Brendan Hansen): I give the worst documentation in
    // the entire world award to WASI, whose best documentation
    // is a C header file, that is itself incorrect. nlink does
    // not exist in the current version of wasmtime, and should
    // not be here, but maybe in the future? Ugh.
    //
    // STILL ANGERY(Brendan Hansen): Actually, nlink does exist
    // in the current version of wasmtime; however its actually
    // a 32-bit value, not 64-bit, which means the offsets were
    // incorrect. I fixed it for now, but when wasmtime updates
    // the size of 'LinkCount' needs to be changed.
    //
    // EVEN ANGRIER(Brendan Hansen): ACTUALLY, I realized today
    // that it has changed (at least for Wasmer). There was not
    // any mention of this on any release documents, but hey, I
    // guess this can actually be 64-bits now.
    //                                   - brendanfh 2020/12/05
    //                                   - brendanfh 2020/12/07
    //                                   - brendanfh 2021/07/10
    nlink    : LinkCount;

    size     : Filesize;
    atim     : Timestamp;
    mtim     : Timestamp;
    ctim     : Timestamp;
}

Userdata :: #type u64;

EventType :: enum (u8) {
    Clock;
    FDRead;
    FDWrite;
}

EventRWFlags :: enum #flags (u16) {
    ReadWriteHangUp;
}

EventFDReadWrite :: struct {
    nbytes : Filesize;
    flags  : EventRWFlags;
}

Event :: struct {
    userdata     : Userdata;
    error        : Errno;
    type         : EventType;
    fd_readwrite : EventFDReadWrite;
}

SubClockFlags :: enum #flags (u16) {
    ClockAbsTime;
}

SubscriptionClock :: struct {
    id        : ClockID;
    timeout   : Timestamp;
    precision : Timestamp;
    flags     : SubClockFlags;
}

SubscriptionFDReadWrite :: struct {
    file_descriptor : FileDescriptor;
}

SubscriptionTagged :: struct {
    tag : EventType;

    use u : struct #union {
        clock    : SubscriptionClock;
        fd_read  : SubscriptionFDReadWrite;
        fd_write : SubscriptionFDReadWrite;
    };
}

Subscription :: struct {
    userdata : Userdata;

    u : SubscriptionTagged;
}

ExitCode :: #type u32;
Signal :: enum (u8) {
    None;
    Hup;
    Int;
    Quit;
    Ill;
    Trap;
    Abrt;
    Bus;
    Fpe;
    Kill;
    USR1;
    Segv;
    USR2;
    Pipe;
    Alrm;
    Term;
    Chld;
    Stop;
    Tstp;
    Ttin;
    Urg;
    Xcpu;
    Xfsz;
    Vtalrm;
    Prof;
    Winch;
    Poll;
    Pwr;
    Sys;
}

RIFlags :: enum #flags (u16) {
    RecvPeek;
    RecvWaitAll;
}

ROFlags :: enum #flags (u16) {
    RecvDataTruncated :: 1;
}

SIFlags :: enum #flags (u16) {
    None;
}

SDFlags :: enum #flags (u16) {
    RD;
    WR;
}

PreopenType :: enum (u8) {
    Dir :: 0x00;
}

PrestatDir :: struct {
    pr_name_len : Size;
}

PrestatTagged :: struct {
    tag : PreopenType;

    u : struct #union {
        dir : PrestatDir;
    };
}


// FUNCTIONS
args_get       :: (argv: & &u8, argv_buf: &u8) -> Errno #foreign WASI_VERSION "args_get"---
args_sizes_get :: (argc: &Size, argv_buf_size: &Size) -> Errno #foreign WASI_VERSION "args_sizes_get" ---

environ_get       :: (environ: & &u8, environ_buf: &u8) -> Errno #foreign WASI_VERSION "environ_get" ---
environ_sizes_get :: (environc: &Size, environ_buf_size: &Size) -> Errno #foreign WASI_VERSION "environ_sizes_get" ---

clock_res_get  :: (id: ClockID, resolution: &Timestamp) -> Errno #foreign WASI_VERSION "clock_res_get" ---
clock_time_get :: (id: ClockID, precision: Timestamp, time: &Timestamp) -> Errno #foreign WASI_VERSION "clock_time_get" ---

fd_advise             :: (fd: FileDescriptor, offset: Filesize, len: Filesize, advice: Advice) -> Errno #foreign WASI_VERSION "fd_advise" ---
fd_allocate           :: (fd: FileDescriptor, offset: Filesize, len: Filesize) -> Errno #foreign WASI_VERSION "fd_allocate" ---
fd_close              :: (fd: FileDescriptor) -> Errno #foreign WASI_VERSION "fd_close" ---
fd_datasync           :: (fd: FileDescriptor) -> Errno #foreign WASI_VERSION "fd_datasync" ---
fd_fdstat_get         :: (fd: FileDescriptor, stat: &FDStat) -> Errno #foreign WASI_VERSION "fd_fdstat_get" ---
fd_fdstat_set_flags   :: (fd: FileDescriptor, flags: FDFlags) -> Errno #foreign WASI_VERSION "fd_fdstat_set_flags" ---
fd_fdstat_set_rights  :: (fd: FileDescriptor, rights_base: Rights, rights_inheriting: Rights) -> Errno #foreign WASI_VERSION "fd_fdstat_set_rights" ---
fd_filestat_get       :: (fd: FileDescriptor, buf: &FileStat) -> Errno #foreign WASI_VERSION "fd_filestat_get" ---
fd_filestat_set_size  :: (fd: FileDescriptor, size: Filesize) -> Errno #foreign WASI_VERSION "fd_filestat_set_size" ---
fd_filestat_set_times :: (fd: FileDescriptor, atim: Timestamp, mtim: Timestamp, fst_flags: FSTFlags) -> Errno #foreign WASI_VERSION "fd_filestat_set_times" ---
fd_pread              :: (fd: FileDescriptor, iovs: &IOVec, iovs_len: Size, offset: Filesize, nread: &Size) -> Errno #foreign WASI_VERSION "fd_pread" ---
fd_prestat_get        :: (fd: FileDescriptor, buf: &PrestatTagged) -> Errno #foreign WASI_VERSION "fd_prestat_get" ---
fd_prestat_dir_name   :: (fd: FileDescriptor, path: str) -> Errno #foreign WASI_VERSION "fd_prestat_dir_name" ---
fd_pwrite             :: (fd: FileDescriptor, iovs: &IOVec, iovs_len: Size, offset: Filesize, nwritten: &Size) -> Errno #foreign WASI_VERSION "fd_pwrite" ---
fd_read               :: (fd: FileDescriptor, iovs: &IOVec, iovs_len: Size, nread: &Size) -> Errno #foreign WASI_VERSION "fd_read" ---
fd_readdir            :: (fd: FileDescriptor, buf: &u8, buf_len: Size, cookie: DirCookie, bufused: &Size) -> Errno #foreign WASI_VERSION "fd_readdir" ---
fd_renumber           :: (fd: FileDescriptor, to: FileDescriptor) -> Errno #foreign WASI_VERSION "fd_renumber" ---
fd_seek               :: (fd: FileDescriptor, offset: FileDelta, whence: Whence, newoffset: &Filesize) -> Errno #foreign WASI_VERSION "fd_seek" ---
fd_sync               :: (fd: FileDescriptor) -> Errno #foreign WASI_VERSION "fd_sync" ---
fd_tell               :: (fd: FileDescriptor, offset: &Filesize) -> Errno #foreign WASI_VERSION "fd_tell" ---
fd_write              :: (fd: FileDescriptor, iovs: &IOVec, iovs_len: Size, nwritten: &Size) -> Errno #foreign WASI_VERSION "fd_write" ---

path_create_directory   :: (fd: FileDescriptor, path: str) -> Errno #foreign WASI_VERSION "path_create_directory" ---
path_filestat_get       :: (fd: FileDescriptor, flags: LookupFlags, path: str, buf: &FileStat) -> Errno #foreign WASI_VERSION "path_filestat_get" ---
path_filestat_set_times :: (fd: FileDescriptor, flags: LookupFlags, path: str, atim: Timestamp, mtim: Timestamp, fst_flags: FSTFlags) -> Errno #foreign WASI_VERSION "path_filestat_set_times" ---

path_link :: (fd: FileDescriptor, old_flags: LookupFlags, old_path: str, new_fd: FileDescriptor, new_path: str) -> Errno #foreign WASI_VERSION "path_link" ---
path_open :: (fd: FileDescriptor,
    dirflags: LookupFlags,
    path: str,
    oflags: OFlags,
    fs_rights_base: Rights,
    fs_rights_inherting: Rights,
    fdflags: FDFlags,
    opened_fd: &FileDescriptor,
    ) -> Errno #foreign WASI_VERSION "path_open" ---

path_readlink :: (fd: FileDescriptor, path: str, buf: &u8, buf_len: Size, bufused: &Size) -> Errno #foreign WASI_VERSION "path_readlink" ---
path_remove_directory :: (fd: FileDescriptor, path: str) -> Errno #foreign WASI_VERSION "path_remove_directory" ---
path_rename  :: (fd: FileDescriptor, old_path: str, new_fd: FileDescriptor, new_path: str) -> Errno #foreign WASI_VERSION "path_rename" ---
path_symlink :: (old_path: &u8, old_path_len: Size, fd: FileDescriptor, new_path: str) -> Errno #foreign WASI_VERSION "path_symlink" ---
path_unlink_file :: (fd: FileDescriptor, path: str) -> Errno #foreign WASI_VERSION "path_unlink_file" ---

poll_oneoff :: (input: &Subscription, out: &Event, nsubscriptions: Size, nevents: &Size) -> Errno #foreign WASI_VERSION "poll_oneoff" ---

proc_exit  :: (rval: ExitCode) -> void #foreign WASI_VERSION "proc_exit" ---
proc_raise :: (sig: Signal) -> Errno #foreign WASI_VERSION "proc_raise" ---

sched_yield :: () -> Errno #foreign WASI_VERSION "sched_yield" ---

random_get :: (buf: &u8, buf_len: Size) -> Errno #foreign WASI_VERSION "random_get" ---

sock_recv     :: (fd: FileDescriptor, ri_data: &IOVec, ri_data_len: Size, ri_flags: RIFlags, ro_datalen: &Size, ro_flags: &ROFlags) -> Errno #foreign WASI_VERSION "sock_recv" ---
sock_send     :: (fd: FileDescriptor, si_data: &IOVec, ri_data_len: Size, si_flags: SIFlags, so_datalen: &Size) -> Errno #foreign WASI_VERSION "sock_send" ---
sock_shutdown :: (fd: FileDescriptor, how: SDFlags) -> Errno #foreign WASI_VERSION "sock_shutdown" ---

// Whoever decided that THIS ONE IMPORT should use '-' instead of '_' should be fired.
// Spent way too long trying to figure out why I could not import this function...
thread_spawn :: (td: rawptr) -> u32 #foreign WASI_VERSION "thread-spawn" ---

