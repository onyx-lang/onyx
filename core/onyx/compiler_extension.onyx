package onyx.compiler_extension
#allow_stale_code

use core {
    stdio
    Result
}
use core.alloc {package, arena}
use core.encoding.osad
use core.io

// Types

IncomingMessage :: union {
    Init as 0: struct {
        compiler_version_major: u32
        compiler_version_minor: u32
        compiler_version_patch: u32

        max_protocol_version_supported: u32
    }

    Terminate as 1: struct {
    }

    ExpandMacro as 2: ExpansionInfo
}

OutgoingMessage :: union {
    Init as 0: struct {
        protocol_version: u32
        name: str
    }

    ErrorReport as 1: struct {
        position: Position
        msg: str
    }

    Expansion as 2: struct {
        id: u32
        code: Result(str, ExpansionFailureReason)
    }

    InjectCode as 3: struct {
        code: str
    }
}

ExpansionInfo :: struct {
    id: u32
    location: ExpansionLocation
    position: Position
    macro_name: str
    body: str
}

ExpansionLocation :: enum {
    Expression
    Statement
    TopLevelStatement
}

ExpansionFailureReason :: enum {
    NotSupported
    BadSyntax
}

Position :: struct {
    filename: str
    line: u32
    column: u32
    length: u32
}


// Code

ExtensionContext :: struct {
    protocol_version: u32
    name: str
    proc_macros: Map(str, #type (&ExtensionContext, ExpansionInfo) -> Result(str, ExpansionFailureReason))

    arena: arena.Arena
}

ExtensionContext.make :: (name: str) -> (res: ExtensionContext) {
    res.name = name
    res.protocol_version = 1

    res.proc_macros = make(typeof res.proc_macros)
    res.arena = arena.make(context.allocator, 32 * 1024)
    return
}

ExtensionContext.start :: (self: &#Self, callback: (&#Self, msg: IncomingMessage) -> void) {
    use stdin_reader := io.Reader.make(&stdio.stream)

    while true {
        msg: IncomingMessage
        if !osad.deserialize(&msg, typeof msg, &stdin_reader, alloc.as_allocator(&self.arena)) {
            break
        }

        switch msg {
            case .Init as &init {
                self->send(.{
                    Init = .{
                        protocol_version = self.protocol_version,
                        name = self.name
                    }
                })
            }

            case .Terminate do break break

            case .ExpandMacro as em {
                if self.proc_macros->has(em.macro_name) {
                    handler := self.proc_macros->get(em.macro_name)->unwrap()
                    result  := handler(self, em)
                    self->send(.{
                        Expansion = .{
                            id = em.id,
                            code = result
                        }
                    })

                } else {
                    fallthrough
                }
            }

            case _ {
                callback(self, msg)
            }
        }

        alloc.arena.clear(&self.arena)
    }
}

ExtensionContext.send :: (self: &#Self, msg: OutgoingMessage) {
    use stdout_writer := io.Writer.make(&stdio.stream)

    osad.serialize(msg, &stdout_writer)
}

ExtensionContext.handle_macro :: (self: &#Self, name: str, func: (&ExtensionContext, ExpansionInfo) -> Result(str, ExpansionFailureReason)) {
    self.proc_macros->put(name, func)
}


map_position :: (base_pos: Position, pos: Position) => {
    line := do {
        if pos.line == 1 do return base_pos.line
        return pos.line + base_pos.line - 1
    }

    column := do {
        if pos.line == 1 do return base_pos.column + pos.column - 1
        return pos.column
    }

    return Position.{
        filename = base_pos.filename,
        line = line,
        column = column,
        length = pos.length
    }
}

