package core.thread

use runtime
use core {*}
use core.intrinsics.atomics {*}

#package {
    thread_mutex   : sync.Mutex;
    next_thread_id := 1;
    thread_map     : Map(Thread_ID, &Thread);
}


/// An id of a thread.
Thread_ID :: #type i32

/// Represents a thread. Currently, this is very simple; just the id
/// of the thread and whether or not it is alive.
Thread :: struct {
    id    : Thread_ID;
    alive : bool;
}

/// Spawns a new thread using the runtime.__spawn_thread function.
/// The primary job of this function is to create the thread-local
/// storage and stack for the new thread, and pass those on.
/// Currently the stack size is not controllable, but that could
/// be remedied.
spawn :: (t: &Thread, data: &$T, func: (&T) -> void) {
    sync.scoped_mutex(&thread_mutex);

    t.id    = next_thread_id;
    t.alive = true;
    next_thread_id += 1;

    thread_map->put(t.id, t);

    tls_base := raw_alloc(alloc.heap_allocator, __tls_size);
    memory.set(tls_base, 0, __tls_size);

    stack_base := raw_alloc(alloc.heap_allocator, 1 << 20);

    runtime.platform.__spawn_thread(t.id, tls_base, stack_base, func, data);
}

/// Waits for a thread to finish before returning.
/// If the thread was not alive in the first place,
/// immediately return.
join :: (t: &Thread) {
    while t.alive {
        #if runtime.platform.Supports_Futexes {
            runtime.platform.__futex_wait(&t.id, t.id, -1);
        } else {
            // To not completely kill the CPU.
            runtime.platform.__sleep(1);
        }
    }
}

/// Forcefully kill a thread using runtime.__kill_thread.
/// Does nothing if the thread was not alive.
kill :: (t: &Thread) -> i32 {
    if !t.alive do return -1;

    ret := runtime.platform.__kill_thread(t.id);
    if ret > 0 do __exited(t.id);

    return 1;
}

/// Special procedure that should only be called once globally
/// that initialize the map of thread ids to thread data.
__initialize :: () {
    thread_map->init();
}

/// Special procedure that is called when a thread exits,
/// or by kill() above.
__exited :: (id: i32) {
    sync.scoped_mutex(&thread_mutex);

    thread := thread_map->get(id) ?? null;
    if thread != null {
        thread.alive = false;
        #if runtime.platform.Supports_Futexes {
            runtime.platform.__futex_wake(&thread.id, 1);
        }

        thread_map->delete(id);
    }
}


