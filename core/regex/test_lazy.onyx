use core {*}

main :: () {
    // Let's test a simple lazy case
    pattern := "a+?b";
    text := "aaab";
    
    println("Testing: ", pattern, " against ", text);
    
    // Using the existing functions
    regex := compile(pattern);
    defer regex->destroy();
    
    match := find_with_groups(&regex, text);
    println("Found: ", match.found);
    println("Text: ", match.text);
    println("Start: ", match.start);
    println("End: ", match.end);
}

// Copy essential functions from regex.onyx
Regex :: struct {
    pattern: str;
    states: [..] NFA_State;
    start_state: u32;
    max_group_id: u32;
}

NFA_State :: struct {
    id: u32;
    is_final: bool;
    transitions: [..] Transition;
}

Transition :: struct {
    condition: Match_Condition;
    target: u32;
}

Match_Condition :: union {
    epsilon: void;
    character: u8;
    char_class: Char_Class;
    range: Range;
    char_set: Char_Set;
    negated: &Match_Condition;
    group_start: u32;
    group_end: u32;
    non_capture_group_start: void;
    non_capture_group_end: void;
    anchor: Anchor;
    word_boundary: void;
}

Char_Class :: enum {
    DIGIT;
    WORD;
    SPACE;
    ANY;
}

Range :: struct {
    start: u8;
    end: u8;
}

Char_Set :: struct {
    chars: [..] u8;
    ranges: [..] Range;
    negated: bool;
    has_predefined: [4] bool;
}

Anchor :: enum {
    START;
    END;
    WORD_BOUNDARY;
}

Match :: struct {
    found: bool;
    start: u32;
    end: u32;
    text: str;
    groups: [..] str;
}

// Minimal compile function
compile :: (pattern: str, allocator := context.allocator) -> Regex {
    return Regex.{ pattern = pattern, states = Array.make(NFA_State, allocator = allocator), start_state = 0, max_group_id = 0 };
}

// Minimal find function
find_with_groups :: (regex: &Regex, text: str, allocator := context.allocator) -> Match {
    return Match.{ found = false };
}
