/// This allocator is mostly used for making many fixed-size
/// allocation (i.e. allocations that will not need to change
/// in size, such as game entities or position structs). The
/// power of this allocator over the heap allocator for this
/// purpose is that it is much faster, since the logic is
/// simpler. Another power of this allocator over something
/// such as a dynamic array is that the dynamic array could
/// relocate and cause any pointers to the data inside to
/// become invalidated; this is definitely not behaviour you
/// want. This arena allocator can grow as large as needed,
/// while guaranteeing that the memory inside of it will
/// never move.
package core.alloc.arena

use core

// Deprecated struct 'ArenaState'. Use 'Arena' instead.
ArenaState :: Arena

/// Stores internal details used during arena allocations.
Arena :: struct {
    backing_allocator : Allocator;

    first_arena   : &ArenaBlock;
    current_arena : &ArenaBlock;
    
    size       : u32;
    arena_size : u32;
}

#local
ArenaBlock :: struct { next : &ArenaBlock; }

#local
arena_alloc_proc :: (data: rawptr, aa: AllocationAction, size: u32, align: u32, oldptr: rawptr) -> rawptr {
    alloc_arena := cast(&Arena) data;

    if aa == .Alloc {
        // An allocation of this size does not fit into a single arena,
        // so make a new "special" arena that only stores this allocation.
        if size > alloc_arena.arena_size - sizeof rawptr {
            ret_arena := cast(&ArenaBlock) raw_alloc(alloc_arena.backing_allocator, size + sizeof rawptr);
            new_arena := cast(&ArenaBlock) raw_alloc(alloc_arena.backing_allocator, alloc_arena.arena_size);

            if ret_arena == null || new_arena == null do return null;

            alloc_arena.size = sizeof rawptr;

            alloc_arena.current_arena.next = ret_arena;
            ret_arena.next = new_arena;
            new_arena.next = null;
            
            alloc_arena.current_arena = new_arena;

            return cast(rawptr) (cast([&] u8) ret_arena + sizeof rawptr);
        }

        if alloc_arena.size % align != 0 {
            alloc_arena.size += align - (alloc_arena.size % align);
        }

        if alloc_arena.size + size >= alloc_arena.arena_size {
            new_arena := cast(&ArenaBlock) raw_alloc(alloc_arena.backing_allocator, alloc_arena.arena_size);
            if new_arena == null do return null;

            alloc_arena.size = sizeof rawptr;

            new_arena.next = null;
            alloc_arena.current_arena.next = new_arena;
            alloc_arena.current_arena = new_arena;
        }

        retval := cast(rawptr) (cast([&] u8) alloc_arena.current_arena + alloc_arena.size);
        alloc_arena.size += size;

        return retval;
    }

    if aa == .Resize {
        newptr := arena_alloc_proc(data, .Alloc, size, align, oldptr);
        if newptr == null do return null;

        // This is incorrect, but because there is not an "old size",
        // this is the best possible.
        core.memory.copy(newptr, oldptr, size);

        return newptr;
    }

    return null;
}

/// Makes a new arena.
///
/// `arena_size` specifies the size of each individual arena page, which must be at least 4 bytes
/// in size (but should be quite a bit large).
make :: (backing: Allocator, arena_size: u32) -> Arena {
    assert(arena_size >= 4, "Arena size was expected to be at least 4 bytes.");
    
    initial_arena := cast(&ArenaBlock) raw_alloc(backing, arena_size);
    initial_arena.next = null;

    return Arena.{
        backing_allocator = backing,
        first_arena       = initial_arena,
        current_arena     = initial_arena,

        size              = sizeof rawptr,
        arena_size        = arena_size,
    };
}

#match core.alloc.as_allocator make_allocator
make_allocator :: (rs: &Arena) -> Allocator {
    return Allocator.{
        func = arena_alloc_proc,
        data = rs,
    };
}

/// Frees all pages in an arena.
free :: (arena: &Arena) {
    walker := arena.first_arena;
    trailer := walker;
    while walker != null {
        walker = walker.next;
        raw_free(arena.backing_allocator, trailer);
        trailer = walker;
    }

    arena.first_arena   = null;
    arena.current_arena = null;
    arena.size          = 0;
}

/// Clears and frees every page, except for first page.
clear :: (arena: &Arena) {
    walker := arena.first_arena.next;

    while walker != null {
        next := walker.next;
        raw_free(arena.backing_allocator, walker);
        walker = next;
    }

    arena.first_arena.next = null;
    arena.size = sizeof rawptr;
}

/// Returns the number of pages in the arena.
get_allocated_arenas :: (arena: &Arena) -> u32 {
    arenas := 0;
    walker := arena.first_arena;
    while walker != null {
        arenas += 1;
        walker = walker.next;
    }

    return arenas;
}

/// Returns the number of bytes used by the arena.
get_allocated_bytes :: (arena: &Arena) -> u32 {
    return get_allocated_arenas(arena) * (arena.arena_size - 1) + arena.size;
}

/// Creates an arena allocator and automatically applies it to the context's allocator
/// in the current scope.
///
///     foo :: () {
///         alloc.arena.auto();
///     
///         // Lazily allocate everything, knowing that it will
///         // be freed when this function returns.
///         for 100 {
///             s := string.copy("Make a copy of me!");
///         }
///     }
auto :: #match {
    macro (size := 32 * 1024, $dest: Code = [](context.allocator)) {
        use core.alloc {arena, heap_allocator}

        a := arena.make(heap_allocator, size);
        old_allocator := #unquote dest;
        (#unquote dest) = arena.make_allocator(&a);
        defer {
            arena.free(&a);
            (#unquote dest) = old_allocator;
        }
    },

    macro (body: Code, size := 32 * 1024) -> i32 {
        auto :: auto

        #context_scope {
            auto(size); 
            #unquote body;
        }

        return 0;
    }
}

/// Creates an arena allocator to be used as the temporary allocator
/// in the code block.
///
///     foo :: () {
///         alloc.arena.auto_temp() {
///             for 1000 {
///                 // Will be automatically freed
///                 x := new_temp(i32);
///             }
///         }
///     }
auto_temp :: macro (body: Code) -> i32 {
    use core.alloc {arena, heap_allocator}
    a := arena.make(heap_allocator, 32 * 1024);

    old_allocator := context.temp_allocator;
    context.temp_allocator = arena.make_allocator(&a);

    #unquote body;

    arena.free(&a);
    context.temp_allocator = old_allocator;
}
