package core.alloc.pool

// A pool allocator is an O(1) allocator that is capable of allocating and freeing.
// It is able to do both in constant time because it maintains a linked list of all
// the free elements in the pool. When an element is requested the first element of
// linked list is returned and the list is updated. When an element is freed, it
// becomes the first element. The catch with this strategy however, is that all of
// the allocations must be of the same size. This would not be an allocator to use
// when dealing with heterogenous data, but when doing homogenous data, such as
// game entities, this allocator is great. It allows you to allocate and free as
// many times as you want, without worrying about fragmentation or slow allocators.
// Just make sure you don't allocate more than the pool can provide.

PoolAllocator :: struct (Elem: type_expr) {
    buffer     : [] Elem;
    first_free : ^Elem;
}

#private_file
pool_allocator_proc :: (pool: ^PoolAllocator($Elem), aa: AllocationAction, size: u32, align: u32, oldptr: rawptr) -> rawptr {
    switch aa {
        case AllocationAction.Alloc {
            assert(size == sizeof Elem, "Allocating wrong size from pool allocator.");
            return pool_alloc(pool);
        }

        case AllocationAction.Resize {
            assert(false, "Cannot resize in a pool allocator!");
            return null;
        }

        case AllocationAction.Free {
            pool_free(pool, ~~ oldptr);
            return null;
        }
    }

    return null;
}

pool_alloc :: (pool: ^PoolAllocator($Elem)) -> ^Elem {
    if pool.first_free == null do return null;

    defer pool.first_free = cast(^Elem) *(cast(^rawptr) pool.first_free);
    return pool.first_free;
}

pool_free :: (pool: ^PoolAllocator($Elem), elem: ^Elem) {
    // TODO: Maybe add a check that the elem pointer is actually in the buffer?? 
    *(cast(^rawptr) elem) = cast(rawptr) pool.first_free;
    pool.first_free = elem;
}


// This could become: proc (buffer: [] u8, $Elem: type_expr) -> PoolAllocator(Elem)
// when that feature is implemented.
make :: (buffer: [] $Elem) -> PoolAllocator(Elem) {
    assert(sizeof Elem >= sizeof rawptr, "Cannot have a pool allocator of a type less than a rawptr in size.");

    for i: 0 .. buffer.count - 1 {
        *(cast(^rawptr) ^buffer[i]) = cast(rawptr) ^buffer[i + 1];
    }

    *(cast(^rawptr) ^buffer[buffer.count - 1]) = null;

    return <PoolAllocator(Elem)>.{
        buffer     = buffer,
        first_free = ^buffer[0],
    };
}

make_allocator :: (pool: ^PoolAllocator($Elem)) -> Allocator {
    return Allocator.{
        func = #solidify pool_allocator_proc { Elem = Elem },
        data = pool,
    };
}