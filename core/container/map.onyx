package core.map

use core {array, hash, memory, math, conv, Optional}
use core.intrinsics.onyx { __initialize }

//
// Map is a generic hash-map implementation that uses chaining.
// Values can be of any type. Keys must of a type that supports
// the core.hash.hash, and the '==' operator.
//
@conv.Custom_Format.{ #solidify format_map {K=Key_Type, V=Value_Type} }
Map :: struct (Key_Type: type_expr, Value_Type: type_expr) where ValidKey(Key_Type) {
    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(Key_Type, Value_Type);

    // The value provided by `map.get`, if nothing was found.
    default_value : Value_Type;

    Entry :: struct (K: type_expr, V: type_expr) {
        next  : i32;
        hash  : u32;
        key   : K;
        value : V;
    }
}

#local ValidKey :: interface (t: $T) {
    // In order to use a certain type as a key in a Map, you must
    // provide an implementation of core.hash.hash() for that type,
    // and you must provide an operator overload for ==.

    { hash.hash(t) } -> u32;
    { t == t       } -> bool;
}

#inject Map {
    init    :: init
    has     :: has
    get     :: get
    get_ptr :: get_ptr
    get_opt :: get_opt
    get_ptr_or_create :: get_ptr_or_create
    put     :: put
    delete  :: delete
    update  :: update
    clear   :: clear
    empty   :: empty
    literal :: literal
    as_iter :: as_iter
}


//
// Allows for creation of a Map using make().
//
//     m := make(Map(str, i32));
//
#overload
__make_overload :: macro (x: &Map($K, $V), allocator := context.allocator) =>
    #this_package.make(K, V);

//
// Creates and initializes a new map using the types provided.
make :: macro ($Key: type_expr, $Value: type_expr, default := Value.{}) -> Map(Key, Value) {
    map : Map(Key, Value);
    #this_package.init(&map, default = default);
    return map;
}

//
// Initializes a map.
init :: (use map: &Map($K, $V), default := V.{}) {
    __initialize(map);

    allocator = context.allocator;
    default_value = default;

    hashes = builtin.make([] u32, 8, allocator=allocator);
    array.fill(hashes, -1);

    array.init(&entries, allocator=allocator);
}

//
// Allows for deletion of a Map using delete(&map).
#match builtin.delete core.map.free

//
// Destroys a map and frees all memory.
free :: (use map: &Map) {
    if hashes.data != null  do memory.free_slice(&hashes, allocator=allocator);
    if entries.data != null do array.free(&entries);
}

//
// Sets the value at the specified key, or creates a new entry
// if the key was not already present.
put :: (use map: &Map, key: map.Key_Type, value: map.Value_Type) {
    lr := lookup(map, key);

    if lr.entry_index >= 0 {
        entries[lr.entry_index].value = value;
        return;
    }

    entries << .{ hashes[lr.hash_index], lr.hash, key, value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(map) do grow(map);
}

//
// Returns true if the map contains the key.
has :: (use map: &Map, key: map.Key_Type) -> bool {
    lr := lookup(map, key);
    return lr.entry_index >= 0;
}

//
// Returns the value at the specified key, or map.default_value if
// the key is not present.
//
// This is subject to change with the addition of Optional to the
// standard library.
//
get :: (use map: &Map, key: map.Key_Type) -> map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return entries[lr.entry_index].value;

    return default_value;
}

//
// Returns a pointer to the value at the specified key, or null if
// the key is not present.
get_ptr :: (use map: &Map, key: map.Key_Type) -> &map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return &entries[lr.entry_index].value;

    return null;
}

//
// Returns a pointer to the value at the specified key. If the key
// is not in the map, a new value is created and inserted, then the
// pointer to that value is returned.
get_ptr_or_create :: (use map: &Map, key: map.Key_Type) -> &map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index < 0 {
        put(map, key, .{});
        lr = lookup(map, key);
    }

    return &entries[lr.entry_index].value;
}

//
// Returns an Optional of the value at the specified key. The Optional
// has a value if the key is present, otherwise the optional does not
// have a value.
get_opt :: (use map: &Map, key: map.Key_Type) -> ?map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return Optional.make(entries[lr.entry_index].value);

    return .{};
}

//
// Removes an entry from the map.
delete :: (use map: &Map, key: map.Key_Type) {
    lr := lookup(map, key);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(&entries);
        return;
    }

    array.fast_delete(&entries, lr.entry_index);
    last := lookup(map, entries[lr.entry_index].key);

    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

//
// Helper macro that finds a value by the key, and if it exists,
// runs the code, providing an `it` variable that is a pointer
// to the value.
//
//     m: Map(str, i32);
//     m->update("test") {
//         *it += 10;
//     }
// or:
//     m->update("test", #(*it += 10));
//
update :: macro (map: &Map, key: map.Key_Type, body: Code) {
    lookup_ :: lookup
    lr := lookup_(map, key);

    if lr.entry_index >= 0 {
        it := &map.entries[lr.entry_index].value;
        #unquote body;
    }
}

//
// Removes all entries from the hash map. Does NOT
// modify memory, so be wary of dangling pointers!
clear :: (use map: &Map) {
    for i: 0 .. hashes.count do hashes.data[i] = -1;
    entries.count = 0;
}

//
// Returns if the map does not contain any elements.
empty :: (use map: &Map) -> bool {
    return entries.count == 0;
}

//
// Helper procedure to nicely format a Map when printing.
// Rarely ever called directly, instead used by conv.format_any.
format_map :: (output: &conv.Format_Output, format: &conv.Format, x: &Map($K, $V)) {
    if format.pretty_printing {
        output->write("{\n");
        for& x.entries {
            conv.format(output, "    {\"p} => {\"p}\n", it.key, it.value);
        }
        output->write("}");

    } else {
        output->write("{ ");
        for& x.entries {
            if !#first do output->write(", ");
            conv.format(output, "{\"p} => {\"p}", it.key, it.value);
        }
        output->write(" }");
    }
}

//
// Quickly create a Map with some entries.
//
//     Map.literal(str, i32, .[
//         .{ "test", 123 },
//         .{ "foo",  456 },
//     ]);
//
literal :: ($Key: type_expr, $Value: type_expr, values: [] MapLiteralValue(Key, Value)) => {
    m := core.map.make(Key, Value);
    for & values {
        m->put(it.key, it.value);
    }

    return m;
}

#local
MapLiteralValue :: struct (K: type_expr, V: type_expr) {
    key: K;
    value: V;
}

//
// Produces an iterator that yields all values of the map,
// in an unspecified order, as Map is unordered.
as_iter :: (m: &Map) =>
    core.iter.generator(
        &.{ m = m, i = 0 },

        ctx => {
            if ctx.i < ctx.m.entries.count {
                defer ctx.i += 1;
                return &ctx.m.entries.data[ctx.i], true;
            }

            return .{}, false;
        });


//
// Helper operator overloads for accessing values, accessing
// values by pointer, and setting values.
#operator []  macro (map: Map($K, $V), key: K) -> V      { return #this_package.get(&map, key); }
#operator &[] macro (map: Map($K, $V), key: K) -> &V     { return #this_package.get_ptr(&map, key); }
#operator []= macro (map: Map($K, $V), key: K, value: V) { #this_package.put(&map, key, value); }

//
// Private symbols
// 
// These are used for the implementation of Map,
// but do not need to be used by any other part
// of the code.
//

#local {
    MapLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
        hash        : u32 = 0;
    }

    lookup :: (use map: &Map, key: map.Key_Type) -> MapLookupResult {
        if hashes.data == null do init(map);
        lr := MapLookupResult.{};

        hash_value: u32 = hash.hash(key);
        lr.hash = hash_value;

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].hash == hash_value {
                if entries[lr.entry_index].key == key do return lr;
            }

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use map: &Map) => entries.count >= (hashes.count >> 2) * 3;

    grow :: (use map: &Map) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(map, new_size);
    }

    rehash :: (use map: &Map, new_size: i32) {
        memory.free_slice(&hashes, allocator);
        hashes = builtin.make([] u32, new_size, allocator=allocator);
        array.fill(hashes, -1);

        for &entry: entries do entry.next = -1;

        index := 0;
        for &entry: entries {
            defer index += 1;

            hash_index := entry.hash % hashes.count;
            entries[index].next = hashes[hash_index];
            hashes[hash_index] = index;
        }
    }
}
