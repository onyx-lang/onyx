package core.map

use core
use core.array
use core.hash
use core.memory
use core.math
use core.conv

use core {Optional}
use core.intrinsics.onyx { __initialize }

#doc """
    Map is a generic hash-map implementation that uses chaining.
    Values can be of any type. Keys must of a type that supports
    the core.hash.hash, and the '==' operator.
"""
@conv.Custom_Format.{ #solidify format_map {K=Key_Type, V=Value_Type} }
Map :: struct (Key_Type: type_expr, Value_Type: type_expr) where ValidKey(Key_Type) {
    allocator : Allocator;

    hashes  : [] i32;
    entries : [..] Entry(Key_Type, Value_Type);

    Entry :: struct (K: type_expr, V: type_expr) {
        next  : i32;
        hash  : u32;
        key   : K;
        value : V;
    }
}

#local ValidKey :: interface (T: type_expr) {
    // In order to use a certain type as a key in a Map, you must
    // provide an implementation of core.hash.hash() for that type,
    // and you must provide an operator overload for ==.

    t as T;

    { hash.hash(t) } -> u32;
    { t == t       } -> bool;
}

Map.init    :: init
Map.has     :: has
Map.get     :: get
Map.get_ptr :: get_ptr
Map.get_opt :: get_opt
Map.get_ptr_or_create :: get_ptr_or_create
Map.put     :: put
Map.delete  :: delete
Map.update  :: update
Map.clear   :: clear
Map.empty   :: empty
Map.literal :: literal
Map.as_iter :: as_iter

builtin.Map :: Map


#doc """
   Allows for creation of a Map using make().
  
       m := make(Map(str, i32));
"""
#overload
__make_overload :: macro (x: &Map($K, $V), allocator := context.allocator) =>
    #this_package.make(K, V, allocator);

#doc """
   Creates and initializes a new map using the types provided.
"""
make :: macro ($Key: type_expr, $Value: type_expr, allocator := context.allocator) -> Map(Key, Value) {
    map : Map(Key, Value);
    #this_package.init(&map, allocator);
    return map;
}

#doc "Initializes a map."
init :: (map: &Map($K, $V), allocator := context.allocator) {
    __initialize(map);

    map.allocator = allocator;

    map.hashes = builtin.make([] u32, 8, allocator=allocator);
    array.fill(map.hashes, -1);

    array.init(&map.entries, allocator=allocator);
}

#doc "Allows for deletion of a Map using `delete(&map)`."
#match builtin.delete core.map.free

#doc """
    Destroys a map and frees all memory.
"""
free :: (use map: &Map) {
    if hashes.data != null  do memory.free_slice(&hashes, allocator=allocator);
    if entries.data != null do array.free(&entries);
}

#doc """
    Shallow copies a map using the allocator provided if one is provided, or the allocator on the old map otherwise.
"""
copy :: (oldMap: &Map, allocator: ? Allocator = .None) -> Map(oldMap.Key_Type, oldMap.Value_Type) {
    newMap: typeof *oldMap;
    newMap.allocator = allocator ?? oldMap.allocator;
    newMap.hashes = array.copy(oldMap.hashes, newMap.allocator);
    newMap.entries = array.copy(&oldMap.entries, newMap.allocator);

    return newMap;
}

#doc """
    Sets the value at the specified key, or creates a new entry
    if the key was not already present.
"""
put :: (use map: &Map, key: map.Key_Type, value: map.Value_Type) {
    lr := lookup(map, key);

    if lr.entry_index >= 0 {
        entries[lr.entry_index].value = value;
        return;
    }

    entries << .{ hashes[lr.hash_index], lr.hash, key, value };
    hashes[lr.hash_index] = entries.count - 1;

    if full(map) do grow(map);
}

#doc """
    Returns true if the map contains the key.
"""
has :: (use map: &Map, key: map.Key_Type) -> bool {
    lr := lookup(map, key);
    return lr.entry_index >= 0;
}

#doc """
    Returns the value at the specified key, or map.default_value if
    the key is not present.

    This is subject to change with the addition of Optional to the
    standard library.
"""
get :: (use map: &Map, key: map.Key_Type) -> ? map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return entries[lr.entry_index].value;

    return .{};
}

#doc """
    Returns a pointer to the value at the specified key, or null if
    the key is not present.
"""
get_ptr :: (use map: &Map, key: map.Key_Type) -> &map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return &entries[lr.entry_index].value;

    return null;
}

#doc """
    Returns a pointer to the value at the specified key. If the key
    is not in the map, a new value is created and inserted, then the
    pointer to that value is returned.
"""
get_ptr_or_create :: (use map: &Map, key: map.Key_Type) -> &map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index < 0 {
        put(map, key, .{});
        lr = lookup(map, key);
    }

    return &entries[lr.entry_index].value;
}

#doc """
    **DEPRECATED** - Use `map.get` instead.

    Returns an Optional of the value at the specified key. The Optional
    has a value if the key is present, otherwise the optional does not
    have a value.
"""
get_opt :: (use map: &Map, key: map.Key_Type) -> ?map.Value_Type {
    lr := lookup(map, key);
    if lr.entry_index >= 0 do return Optional.make(entries[lr.entry_index].value);

    return .{};
}

#doc "Removes an entry from the map."
delete :: (use map: &Map, key: map.Key_Type) {
    lr := lookup(map, key);
    if lr.entry_index < 0 do return;

    if lr.entry_prev < 0   do hashes[lr.hash_index]       = entries[lr.entry_index].next;
    else                   do entries[lr.entry_prev].next = entries[lr.entry_index].next;

    if lr.entry_index == entries.count - 1 {
        array.pop(&entries);
        return;
    }

    array.fast_delete(&entries, lr.entry_index);
    last := lookup(map, entries[lr.entry_index].key);

    if last.entry_prev >= 0    do entries[last.entry_prev].next = lr.entry_index;
    else                       do hashes[last.hash_index] = lr.entry_index;
}

#doc """
Helper macro that finds a value by the key, and if it exists,
runs the code, providing an `it` variable that is a pointer
to the value.

    m: Map(str, i32);
    m->update("test") {
        *it += 10;
    }
or:
    m->update("test", [v](*v += 10));
"""  
update :: macro (map: ^Map, key: map.Key_Type, body: Code) {
    lookup_ :: lookup
    lr := lookup_(map, key);

    if lr.entry_index >= 0 {
        it := &map.entries[lr.entry_index].value;
        #unquote body(it);
    }
}

#doc """
    Removes all entries from the hash map. Does NOT
    modify memory, so be wary of dangling pointers!
"""
clear :: (use map: &Map) {
    for i in 0 .. hashes.count do hashes.data[i] = -1;
    entries.count = 0;
}

#doc "Returns if the map does not contain any elements."
empty :: (use map: &Map) -> bool {
    return entries.count == 0;
}

#doc """
    Helper procedure to nicely format a Map when printing.
    Rarely ever called directly, instead used by conv.format_any.
"""
format_map :: (output: &conv.Format_Output, format: &conv.Format, x: &Map($K, $V)) {
    if format.pretty_printing {
        output->write("{\n");
        for& x.entries {
            conv.format(output, "    {\"p} => {\"p}\n", it.key, it.value);
        }
        output->write("}");

    } else {
        output->write("{ ");
        for& x.entries {
            if !#first do output->write(", ");
            conv.format(output, "{\"p} => {\"p}", it.key, it.value);
        }
        output->write(" }");
    }
}

#doc """
    Quickly create a Map with some entries.
   
        Map.literal(str, i32, .[
            .{ "test", 123 },
            .{ "foo",  456 },
        ]);
"""
literal :: ($Key: type_expr, $Value: type_expr, values: [] MapLiteralValue(Key, Value)) => {
    m := core.map.make(Key, Value);
    for & values {
        m->put(it.key, it.value);
    }

    return m;
}

#local
MapLiteralValue :: struct (K: type_expr, V: type_expr) {
    key: K;
    value: V;
}

#doc """
    Produces an iterator that yields all values of the map,
    in an unspecified order, as Map is unordered.
"""
as_iter :: (m: &Map) =>
    core.iter.generator(
        &.{ m = m, i = 0 },

        ctx => {
            if ctx.i < ctx.m.entries.count {
                defer ctx.i += 1;
                return &ctx.m.entries.data[ctx.i], true;
            }

            return .{}, false;
        });


//
// Helper operator overloads for accessing values, accessing
// values by pointer, and setting values.
#operator []  macro (map: Map($K, $V), key: K) -> ?V     { return #this_package.get(&map, key); }
#operator &[] macro (map: Map($K, $V), key: K) -> &V     { return #this_package.get_ptr(&map, key); }
#operator []= macro (map: Map($K, $V), key: K, value: V) { #this_package.put(&map, key, value); }

//
// Private symbols
// 
// These are used for the implementation of Map,
// but do not need to be used by any other part
// of the code.
//

#local {
    MapLookupResult :: struct {
        hash_index  : i32 = -1;
        entry_index : i32 = -1;
        entry_prev  : i32 = -1;
        hash        : u32 = 0;
    }

    lookup :: (use map: &Map, key: map.Key_Type) -> MapLookupResult {
        if hashes.data == null do init(map);
        lr := MapLookupResult.{};

        hash_value: u32 = hash.hash(key);
        lr.hash = hash_value;

        lr.hash_index = hash_value % hashes.count;
        lr.entry_index = hashes[lr.hash_index];

        while lr.entry_index >= 0 {
            if entries[lr.entry_index].hash == hash_value {
                if entries[lr.entry_index].key == key do return lr;
            }

            lr.entry_prev = lr.entry_index;
            lr.entry_index = entries[lr.entry_index].next;
        }

        return lr;
    }

    full :: (use map: &Map) => entries.count >= (hashes.count >> 2) * 3;

    grow :: (use map: &Map) {
        new_size := math.max(hashes.count << 1, 8);
        rehash(map, new_size);
    }

    rehash :: (use map: &Map, new_size: i32) {
        memory.free_slice(&hashes, allocator);
        hashes = builtin.make([] u32, new_size, allocator=allocator);
        array.fill(hashes, -1);

        for &entry in entries do entry.next = -1;

        index := 0;
        for &entry in entries {
            defer index += 1;

            hash_index := entry.hash % hashes.count;
            entries[index].next = hashes[hash_index];
            hashes[hash_index] = index;
        }
    }
}
